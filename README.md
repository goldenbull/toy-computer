# 介绍

用于计算机编程的入门教学。

引入一个极度简化、抽象后的计算机模型，只包含最简单的CPU和内存，逐步引入各种类ASM汇编指令

# 最基本的规则

1. 整个系统只有几个概念：CPU、内存、数字、指令、状态
2. CPU：只由寄存器构成，每个寄存器是一个小格子，可以存一个数字。通过一步步不断复杂化的问题，引入各种功能的寄存器
3. 内存分为数据内存和指令内存
   1. 数据内存由1024个小格子组成，和寄存器一样，每个格子也可以存一个数字，所有格子顺序编号，0-base
   2. 指令内存也是一堆小格子，每个格子一条指令，也顺序编号，且每条指令可以有一个自定义的label
   3. 内存和寄存器的区别：内存比寄存器慢100倍，但量大便宜
4. 数字：只处理有符号整数，且不考虑字节数
5. 指令：指示CPU如何操作寄存器和内存中的数字，全部使用小写，指令前还可以有一个自定义的标签
6. 状态：运行中；运行结束；出错死机，比如除以0，内存越界，出错时会汇报出错原因

# lesson 1 寄存器的简单操作

引入4个通用寄存器ax bx cx dx

引入7条指令：mov add sub mul div input print

每条指令的格式和规则：
- mov：数据存取
  - mov r1, N       // r表示寄存器，N表示立即数
  - mov r1, r2
- add：加法
  - add r1, N       // r1+N --> r1
  - add r1, r2
- sub：减法
  - sub r1, N
  - sub r1, r2
- mul：乘法
  - mul N           // `乘数必须预先放入ax中，结果是ax*N，也放在ax里，即 ax*N --> ax`
  - mul r1
- div：除法
  - div N           // `整数除法，被乘数必须预先放入ax中，ax除以N，商在ax中，余数在dx中，余数始终和ax符号相同，如果N为0，系统死机`
  - div r1
- input：用户输入一个数字，格式错误则直接死机
  - input r1
- print：输出数字到屏幕上，作为一个伪指令，为方便教学，允许使用C风格的字符串
  - print N
  - print r1
  - print STR
  - println N
  - println r1
  - println STR
  - println    // 等价于print "\n"

需要完成的任务：
1. 从1加到3，输出结果
2. 输入两个数，输出两个数的加减乘除的各种结果
3. 从1加到10，输出结果

# lesson 2 内存操作

4个寄存器只能保存4个数字，可以做的事情是非常少的，如果需要保存更多的数字，就需要用到内存了，内存统一通过[寄存器+偏移量]的格式访问，上述各个指令操作内存的格式如下：
- mov：数据存取
  - mov r1, [r2+N]  // [r2+N]表示内存中编号为r2+N的格子，N为0时可以省略不写，也可以为负数，如[ax-4]
  - mov [r1+N], N
  - mov [r1+N], r2
- add：加法
  - add r1, [r2+N]
- sub：减法
  - sub r1, [r2+N]
- mul：乘法
  - mul [r1+N]
- div：除法
  - div [r1+N]
- input：用户输入一个数字，格式错误则直接死机
  - input [r1+N]
- print：输出数字到屏幕上，作为一个伪指令，为方便教学，允许使用C风格的字符串
  - print [r1+N]
  - println [r1+N]

需要完成的任务：
1. 输入4个数，输出这4个数的累加值、最大值、最小值
2. 先输入10个数，然后输入两个编号选择其中的两个数，输出这两个数的加减乘除的各种结果

# lesson 3 循环

对于任务1-3，显然存在一个重复的操作，如果是累加到100，不可能重复写100行代码，我们引入循环来实现

引入新的指令：
- jmp Label    // Label就是目标指令的label，实际上可以通过当前指令和目标指令的序号，换算成一个数字

只有jmp的话，只能实现死循环，还需要根据某种条件判断，中断循环，因此需要引入新的寄存器和指令
- 引入寄存器flg，不能通过mov写入，只能通过cmp指令写入

引入新的指令：
- cmp
  - cmp r1, N   // 比较r1和N的大小，flg=sign(r1-N)
  - cmp r1, r2
  - cmp r1, [r2+N]
- 条件跳转指令
  - je Label     // jump if equal
  - jne Label    // jump if not equal
  - jg Label     // jump if greater
  - jge Label    // jump if greater or equal
  - jl Label     // jump if less
  - jle Label    // jump if less or equal

需要完成的任务：
1. 从1加到10，输出结果
2. 从1加到100，输出结果
3. 输出斐波那契数列的前100项
4. 输入一个数，判断这个数是否是7的倍数
5. 输入一个数，判断这个数的十进制表达里面是否包含7，比如17，271，37，76
6. 输入一个数，判断这个数是否是7的倍数或者包含7
7. 酒桌小游戏：从1到100，轮流数数，跳过所有7的倍数或者包含7的数
8. 输入一个数，判断是否是质数
9. 输出100以内的所有质数

# lesson 4 函数

## 4.1 函数的概念

重新回顾lesson 3的各个任务：
- 任务3的实现方式，可以是逐项往后递推，也可以使用递归函数的方式实现
- 任务4和5，有一段功能相同的部分，实际上也是函数
- 而任务6，则是两个函数组合成的一个函数

函数概念的引入，最直接的方式是从jmp指令出发，考虑“如果跳回去”的问题，于是产生一连串的问题：
1. 如何调回去的问题：jmp之前，想办法保存当前指令的序号，函数执行完毕后，jmp回来继续执行即可
2. 调用者并不确定函数会用到哪些寄存器，所以当前指令的序号只能保存在内存里，且必须是事先约定的内存位置，这一片内存称为stack，即“栈”
3. 函数还会调用其他函数，因此保存指令序号的内存位置还得递增或递减，不能覆盖
4. 函数还有参数和返回值的问题
5. 函数内部还需要保存各种中间结果

为解决以上问题，需要一步步引入新的机制

## 4.2 ip和sp寄存器

首先引入新的寄存器：
- ip, instruction pointer，实际上这个寄存器之前已经隐形的存在了，用于记录下一步将要执行的指令的序号，CPU下一步执行哪条指令，完全依赖这个寄存器的值
  - 系统启动时设为0
  - 非跳转指令，自动+1
  - 跳转指令，设置为目标指令的序号
- sp，stack pointer，记录下一个空闲的可以存放指令序号的内存位置，不妨在系统初始化时设为512

假设函数f的入口是Label，当需要调用f时，需要做的事情是：
```
mov [sp], ip // 注意一般情况下ip是当前正在执行的指令序号+1
add sp, 1
jmp Label
```

f内部，当执行完毕，返回调用者时，需要做的是：
```
sub sp, 1
jmp [sp]
```

## 4.3 call和ret指令

但是这里出现了一个问题：jmp [sp] 这个语法是不合法的

而且，既然每次函数调用和返回都需要干同样的事情，就可以引入新的指令了：
- call Label   // 上述的三步操作：ip入栈，sp+1，jmp到函数入口
- ret         // 上述的两步操作：sp-1，jmp回到调用函数前的位置继续执行

需要注意几点：
- call和ret指令会修改sp和ip的值
- ip不能用mov指令赋值，只能用jmp/je/jne/...这些跳转指令和call/ret指令赋值
- sp是一个通用寄存器，程序员可以随意操作，但由于call和ret会修改sp，因此需要按照规则正确使用sp

## 4.4 参数和返回值

目前已经解决了函数调用和返回的问题，但还需要继续解决函数的参数和返回值的问题。当参数和返回值比较少的时候，可以约定使用寄存器来回传递，但如果参数多了，寄存器是不够用的，需要一个通用的机制。一个自然的想法是：调用者和被调用的函数约定好，在内存里找一块地方，保存参数和返回值。这又引入两个问题：
1. 不同的函数，要避免互相覆盖，那么该如何约定不同的内存位置？
2. 同一个函数，有可能调用自己，比如斐波那契数列的递归算法，该如何避免自己覆盖自己？实际上这是问题1的变体。

结论就是：既然“事先约定的内存位置”，即初始化为512的那一片内存，可以保存ip，那么也同样可以保存参数和返回值，调用者和被调用的函数需要约定好如何存放参数和返回值，程序员通过正确的使用sp寄存器来实现参数和返回值的传递，因为sp寄存器和4个通用寄存器一样，是可以用mov指令和加减乘除指令进行修改的，但程序员需要特别小心，不要用错了。

为了更方便的操作sp寄存器，我们引入新的指令：
- push
  - push N      // 等价于先执行 mov [sp], N 再执行 add sp, 1
  - push r1     // r1只能是通用寄存器ax-dx
- pop
  - pop r1      // 等价于先执行 sub sp, 1 再执行 mov r1, [sp]
  - pop         // 只执行 sub sp, 1
- pushf         // flg寄存器压入栈
- popf

需要再次强调的是，函数的调用者和函数本身，需要约定好参数和返回值如何传递，谁负责操作sp寄存器，双方必须按照一致的约定行动，否则程序就会出错

## 4.5 函数内部计算过程需要保存中间结果

对于稍微复杂一点的计算过程，4个寄存器是不够用的，必须需要在内存中存放各种中间结果，一个函数可以在内存固定的位置存放中间结果，但是会有两个问题：
1. 这个位置其他函数不能用，避免覆盖，所以需要所有的函数都知道其他函数用了哪儿，自己能用哪儿，不能用哪儿，当函数多了之后，这显然是无法维护的
2. 对于递归函数，自己调用自己，那么同一个位置必然要被自己覆盖掉，导致计算过程无法回退，从而整个事情就无法实现了

解决办法和参数、返回值是一样的，可以往栈里面继续增加内容，同一个函数，每次被调用时，sp寄存器都是指向栈的头部位置，不会产生覆盖的问题

## 4.6 额外的工具

为了更方便的使用栈，再引入一个新的寄存器：
- bp, base pointer

bp是一个通用寄存器，完全是为了方便程序员而提供的，和sp一样，程序员也可以随意操作。

call/ret/push/pop会自动改变sp的值，但各种指令都不会自动改变bp的值，bp和sp协同工作，可以更方便的操作栈

最后为方便程序员，再引入几条指令：
- pusha       // 将所有通用寄存器入栈，依次是ax bx cx dx flg bp
- popa        // 和pusha对应，以相反的顺序逐一出栈
- dump        // 输出当前的计算机运行状态，用于观察、调试程序的运行过程，显示正在运行的指令上下文、所有寄存器
- dump r1, N  // 除了上述内容，还显示内存中[r1]到[r1+N-1]的内容，N必须大于等于0
- pause       // 暂停程序，等待用户输入回车后继续
- halt        // 立即结束运行，进入停机状态
- nop         // no operation的缩写，除了ip往前走一步，什么事情也不干


## 任务

有了新的指令和寄存器，将之前的所有任务用函数重新实现一遍，做到：函数片段本身是自包含的，只需要约定参数和返回值的传递方式，此外无需知道调用者的任何信息

# lesson 5

到目前为止，一个抽象意义上的计算机已经功能齐全了，可以实现一些复杂的功能了，我们可以实现各种排序算法，以熟练上述内容

为方便初始化数据，引入随机数指令
- rand
  - rand r1     // 将一个随机数存入r1中，随机数的范围限制在[0, 999]，足够随机，且方便显示
  - rand [r1+N]

任务：
- 随机生成100个数，存到内存里，将其排序，输出排序前和排序后的结果，这一步可以先使用交换排序、冒泡排序等各种基于循环的、非递归的排序算法
- 实现递归的快速排序

# lesson 6

到目前为止，CPU和内存的核心概念已经完备了，下一步是从一行行的指令（实际上就是汇编语言）到C语言的转换

任务：
- 将以上汇编代码逐行翻译成C，从而理解C语言的底层机制

# 汇总

## 寄存器

- 通用寄存器：ax bx cx dx
- 符号寄存器：flg
  - 只能通过cmp popf popa赋值
- 指令寄存器：ip
  - 系统启动时，初始化为0
- 栈寄存器：bp sp
  - 系统启动时，sp初始化为512
  - 某些指令会改变sp的值，sp和bp是专门用于栈操作的，需要特殊对待

## 程序语法

- 用//表示注释
- 每一行一条指令，指令全部小写
- 指令可以有标签，标签可以单独占一行，和下一行的指令是一个整体

样例：
```
start:
  mov ax, 0
  mov cx, 1
loop1:
  add ax, cx
  add cx, 1
  cmp cx, 10
  jg finished
  jmp loop1
finished:
  print ax
  dump ax, 0
```

## 指令一览

以 [toy_asm.g4](antlr/idl/toy_asm.g4) 中的 antlr 描述为准

## release

为方便使用，可以用 pyinstaller 打包
```
D:\src\toy-computer\src\py>pyinstaller -F main.py
```