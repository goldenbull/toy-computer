# 介绍

AI的大发展要求程序员必须精通底层逻辑。

出于计算机编程的入门教学的需要，此处引入一个极度简化、抽象后的计算机模型，只包含最简单的CPU和内存，用一个极度裁剪的ASM汇编指令集，实现完备的冯诺依曼体系。

# 设计

1. 所有的数字都是有符号整数，没有浮点数，且不考虑字节长度问题
   - 在具体的typescript实现中，使用`Number.MIN_SAFE_INTEGER`和`Number.MAX_SAFE_INTEGER`作为溢出判断
2. CPU只有极少的几个寄存器
   - ip
   - ax bx cx dx
   - flg
   - sp bp
3. 内存只有1024个单元
4. 只有几条asm指令
   - mov
   - add sub mul div
   - cmp
   - jmp je jne jl jg jle jge
   - push
   - pop
   - call
   - ret
5. 考虑实际教学需要，增加几条伪指令
   - print println
   - input
   - rand
   - break
   - halt
6. 用分号;开始注释

语法规则见 [toy_asm.g4](antlr/idl/toy_asm.g4) 

说明文档见 [svelte源文件](src/web_frontend/src/routes/manual/+page.svelte)

# 教学过程的逐步深入和展开

## 入门

- 上手熟悉：mov add print指令
- 加减乘除指令，input指令，一个计算器，输入两个数，输出加减乘除的结果
- 从1累加到10，逐行显示"n sum(-.=n)"
  - 尝试使用重复的代码，而非hardcode 1到10，比如增加一个约束：代码中只允许出现数字1
- 使用jmp重复做一件事，但是会死循环（**第一个Wow Moment**）
- 引入cmp, flg, 条件jmp
- 输入n，累加到n
  - **要对输入的数做检查，培养严谨的意识，并引入注释**
- 输出斐波那契数列前n项，此时已经发现4个寄存器不够用了

## 引入内存概念

- 内存操作。
  - **核心思想：将计算和存储分开，以草稿纸类比。引入变量的思想。**
-  使用内存+变量的思想重写程序，输出斐波那契数列前n项
- 九九乘法表

## 承前启后的核心案例：质数判断

- 输入一个数，判断是否是质数
  - 使用简单循环，但也有加速技巧，算法复杂度从n降到sqrt(n)，**10000 --> 50, 体会算法加速的意义。**
- 计算质数表，需要明确每次判断的输入输出的方式，为引入函数做准备
  - 无需限定上限，**第二个Wow Moment**
- 使用筛法，**体会空间换时间的思想。**

## 张益唐的故事，引入孪生质数概念

强调函数在数学中的核心地位，同时也是计算机中的核心概念

- 输入一个数n，判断n和n+2是否都是质数
- 用一个简单的函数说明问题，`f(n) = n*n + n + 1`
  - 问题：如何jmp回去
  - 引入IP寄存器
  - 从label到offset的原理
  - 大家想办法
  - **引入模块化思想**，函数的自包含的性质

## 引入栈的概念

- 引入sp寄存器和push pop指令

## 完成函数的拼图

- 引入call和ret指令
- 做一些实验演示一下
- 尝试用函数实现 f(n)=n*n+n+1
- 引入局部变量的需求，从而引入bp寄存器
- 最终完成函数的整个拼图，然后实现孪生素数的搜索，**第三个Wow Moment**

### 更多的练习

- 随机生成100个数，存到内存里，将其排序，输出排序前和排序后的结果，这一步可以先使用交换排序、冒泡排序等各种基于循环的、非递归的排序算法
- 斐波那契数列第n项的递归实现
- 使用动画模式观看以上两个程序的运行过程，**又一个Wow Moment**

### 函数的其他细节，可以留待后面和C结合的部分

- 多个参数、返回值的时候，栈上保存参数和返回值
- 谁来退sp指针释放参数的栈空间
  - 规范的C函数调用：参数从右向左入栈，函数调用结束后由调用者负责清理栈空间

### 函数`frame`的内存布局，一个demo

用一个例子演示函数的进栈和出栈机制

假设一个简单的平方和函数 `f1(a,b) = a*a + b*b`

这个函数有两个参数 a 和 b，有一个返回值，计算时需要一个临时变量

那么这个函数的frame的内存布局如下（注意栈是向下生长的，参数是从后向前入栈的，此处演示使用栈而不是寄存器返回结果）：

```
------------------
[bp+5] b        第二个参数   <-- 开始一次函数调用前，sp 指向这个位置
[bp+4] a        第一个参数
[bp+3] r        函数的返回值
[bp+2] ip       调用 call 时 ip 压入栈
[bp+1] old bp   前一个 frame 的起点
[bp+0] x1       函数内部运算时需要的临时变量 <-- 执行函数内部的指令时，bp 指向这个位置
[]              <-- 执行函数内部的指令时，sp 指向这个位置，即下一个可用的栈的位置
```

调用函数的方式：

```
push ax         ; 第一个参数
push bx         ; 第二个参数
sub sp, 1       ; 为返回值预留位置
call _f1        ; ip 自动入栈，并跳转到 _f1 位置
pop ax          ; 获得返回值，存入ax中
add sp, 2       ; 函数调用完毕，释放参数的栈空间
```

对应的函数的实现：

```
_f1:
    ; 创建新的frame
    push bp
    mov bp, sp

    ; 为临时变量预留空间
    sub sp, 1
    
    ; 使用临时变量进行计算
    mov ax, [bp+4]  ; ax <- a
    mul ax          ; ax <- a*a
    mov [bp], ax    ; 存入临时变量
    mov ax, [bp+5]  ; ax <- b
    mul ax          ; ax <- b*b
    add ax, [bp]    ; 给ax加上之前已经算好的临时变量

    ; 返回值
    mov [bp+3], ax

    ; 退回之前的frame
    mov sp, bp
    pop bp

    ; ip出栈，函数返回
    ret
```
