# 介绍

用于计算机编程的入门教学。

引入一个极度简化、抽象后的计算机模型，只包含最简单的CPU和内存，逐步引入各条ASM汇编指令

# 最基本的规则

1. 整个系统只有几个概念：指令、CPU、寄存器、数字、内存
2. 指令：程序的最基本单位，一条语句就是一个指令，由CPU负责执行，每条指令的执行逻辑都是极度简单、清晰、明确的，指令的语句全部使用小写，每条指令前还可以有一个或多个自定义的标签
3. 用分号;开始注释，等同于C语言的//和python语言的#
4. CPU、寄存器
   1. CPU负责执行指令，具体执行指令的细节涉及到很低层的数字电路了，不是这里要解决的问题，因此执行过程可以简化，只需要抽象了解加减乘除等基本运算等逻辑就可以。
   2. 寄存器在CPU内部，每个寄存器是一个小格子，可以存一个数字，要强调寄存器的“临时”性质
5. 数字：只处理有符号整数，不考虑浮点数，也不考虑不同长度的整型
6. 内存，用来保存数据和指令，分为数据内存和指令内存
   1. 数据内存由1024个小格子组成，和寄存器一样，每个格子也可以存一个数字，所有格子顺序编号，0-base
   2. 指令内存也是一堆小格子，每个格子一条指令，也顺序编号，且每条指令可以有一个自定义的label
   3. 内存和寄存器的区别：内存比寄存器慢100倍，但量大便宜
7. 教学时的类比：
   1. 指令内存和指令：操作手册，每一步的操作（不可擦写）
   2. 数据内存：黑板（面积大，可擦写）
   3. 寄存器：草稿纸（面积小，可擦写）
   4. CPU：操作员，人

文档见 src/web_frontend/src/routes/manual/+page.svelte

# lesson-1 寄存器的简单操作

## 核心概念：寄存器的赋值和算术运算

4个通用寄存器和加减乘除运算

## 需要完成的任务

1. 从1加到10，输出结果
2. 输入两个数，输出两个数的加减乘除的各种结果，注意乘除法会占用ax和dx

# lesson-2 内存操作

## 核心概念：按地址读写内存，变量

## 需要完成的任务

1. 输入4个数，然后依次输出：这4个数本身的值，4个数的和、平方和


# lesson-3 循环，判断，跳转

## 核心概念：条件控制，跳转，继续理解变量，理解使用变量作为下标访问数组的模式

以上各个任务中，已经出现了一些反复执行的代码片段，我们引入循环，避免不必要的重复

为了实现**反复执行同一段代码**的功能，引入新的指令和寄存器
- flg寄存器和cmp指令
- 无条件跳转
- 条件跳转

## 理解jmp指令的实质，IP寄存器

首先通过dump指令理解jmp指令是如何将字符串形式的label转换为数字的，例如运行以下代码：

```
    mov ax, 0
loop1:
    add ax, 1
    println ax
    cmp ax, 100
    jne loop1
    je continue
    print "this op will be skipped"
continue:
    print "jump to here"
    dump
```

重点观察每条jmp指令后面的offset，实际上jmp指令是根据offset的数值而不是label的字符串进行操作的

引入ip寄存器，实际上这个寄存器之前已经隐形的存在了

- ip
  - instruction pointer的意思
  - 用于记录下一步将要执行的指令的序号，CPU下一步执行哪条指令，完全依赖这个寄存器的值
  - 系统启动时设为0
  - 非跳转指令，自动+1
  - 跳转指令，设置为目标指令的序号

## 需要完成的任务

循环和跳转是引入函数之前的核心技能，需要加强练习，提高熟练度，因此要多一些任务。通过练习，理解编程中的核心理念：模块化
1. 一件任务可以拆解为若干件子任务，子任务的代码可以复用，即算法的模块化
2. 每件任务都需要一片独立的内存空间，即数据的模块化，在没有引入函数和栈之前，肯定只能用全局变量，但也能体会到这一点

任务：

1. 从1加到10，输出结果
2. 输入一个数N，从1加到N，输出结果
3. 输出斐波那契数列的前100项
4. 输入一个数，判断这个数是否是7的倍数
5. 输入一个数，判断这个数的十进制表达里面是否包含7，比如17，271，37，76
6. 输入一个数，判断这个数是否是7的倍数或者包含7
7. 小游戏：从1到100，轮流数数，跳过所有7的倍数或者包含7的数，结合前面几个任务，体会如何实现代码的复用
8. 输入一个数，判断是否是质数
9. 输出10000以内的所有质数
   1. 方法一：每个数字采用8的办法进行判断
   2. 方法二：使用筛法，观察两者的性能差异。注意筛法实际上需要引入变长数组的数据结构。
10. 孪生质数问题：找出10000以内的所有孪生质数，即N和N+2都是质数的情况。
这个问题的关键点在于，此时还未引入函数的概念，N和N+2的质数判断是在代码中的不同地方，
因此要么复制一遍质数判断的代码，要么使用jmp模拟call，并通过一个变量用jmp模拟ret，根据变量的不同的值，jmp回到不同的调用处，
但无论哪种方式，都很丑陋且不可扩展，从而为引入函数提供了理由


# lesson-4 函数

在解决3.10孪生质数问题时，可以体会到代码复用的核心问题是两个：
1. 每个代码模块（实际上就是函数）都需要独立的内存空间用于保存计算的中间结果，如何避免各个函数的内存空间发生冲突
2. 不同的调用者调用同一个函数，函数执行完毕后，如何返回不同的位置

如果一个函数F的计算逻辑稍微复杂一点，还可能会调用F2，F2再调用F3，层层嵌套，那么每个函数都需要独立的内存空间，
且每一次函数调用都需要保存返回的位置，该如何实现这些功能？

## 栈和SP、BP寄存器

用一个类比来理解自上而下、层层分解的函数调用的过程：我们在工作台上组装一辆电车，底盘组装完毕后，需要组装电动机，
这时就得离开当前的工作台，在一个全新的工作台上组装电动机，电动机组装过程中，需要组装中间的转子部件，这时又得再去一个全新的工作台，
当完成每个工作台的任务时，就得回到前一个工作台。

函数调用和返回，就是这样一个逐层深入、逐层退出的过程，这个过程的特点是：
1. 每个函数都有一个“工作台”，即独占一块内存，各个函数的这块内存互不干扰
2. 通过某种机制，记录函数的调用者和被调用者之间的关系，当被调用的函数执行完毕后，能正确的回到之前调用者发起调用的位置，继续往后执行

首先，可以直观的想到，按照函数逐级调用的关系，每个函数的“工作台”可以依次排列在内存里，这就是栈（stack）这个数据结构发挥作用的地方。

我们引入一个新的寄存器sp：

- sp
    - stack pointer的意思
    - 记录下一个空闲的可以存放数据的内存位置，和现代CPU保持一致，在系统初始化时设为内存的最大值，即最后一个内存空间，往地址变小的方向增长（现代CPU的这种设计，是为了尽可能提高内存使用效率）
    - 这是一个通用寄存器，用户可以随意操作
    - 但实际中sp的使用需要遵循规范，因为某些指令会自动改变sp的值，如果违反了使用规范，就会导致程序出错

实际上sp寄存器记录的是“当前工作台内部”的可用位置，而“当前工作台”的起点，我们使用一个新的寄存器bp来记录

- bp
  - base pointer的意思
  - bp是一个通用寄存器，完全是为了方便程序员而提供的，和sp一样，程序员也可以随意操作
  - bp和使用也需要遵循规范，通过和sp配合使用，就可以在内存中记录所有工作台的信息


引入栈的概念和bp、sp寄存器之后，内存就分为两个部分了，前面部分是程序可以随意使用的，称为 **堆（heap）**，后面部分格子是给 **栈（stack）** 专用的，sp始终指向栈的顶部的空闲位置

为了更方便的操作sp寄存器，我们引入新的指令：`push pushf pop popf`

## 解决函数返回地址的问题

再次回顾代码模块化面临的问题，将一段代码变成可以重复调用的函数，会有以下一系列问题：

1. 如何跳转回去：一个直观的想法，是通过保存和恢复ip寄存器来实现这个功能，jmp之前，想办法保存ip寄存器的值，函数执行完毕后，jmp回来继续执行
2. 寄存器是临时空间，随时会被用到，因此ip寄存器的值只能保存在内存里
3. 函数还会调用其他函数，因此保存ip寄存器的内存位置需要自动变化，以避免互相覆盖
4. 函数还有参数和返回值的问题
5. 函数内部还需要保存各种中间结果（即自己独占的工作台），不同函数的工作内存需要相互独立，互不干扰

以上和内存相关的问题，已经可以通过栈和sp指针解决，接下来我们解决ip寄存器保存和恢复的问题

为此我们引入函数调用最核心的两条指令：`call ret`

需要注意几点：

- `call`和`ret`指令会修改`sp`和`ip`的值
- `ip`不能用`mov`指令赋值，只能用`jmp`/`je`/`jne`等跳转指令和`call`/`ret`指令赋值
- `sp`是一个通用寄存器，程序员可以随意操作，但由于`call`和`ret`会修改`sp`，因此需要按照规范正确使用`sp`


## 任务

函数是编程语言的核心内容，同样需要充分熟练，但这一阶段可以先实现简单的函数调用，主要目的是熟悉call和ret的使用，
参数和返回值可以使用寄存器传递，更复杂的参数和返回值的使用，留给下一部份

1. 将3.4到3.10的各个任务改用函数实现
2. 生成100个随机数，进行排序。此处可以使用交换排序、插入排序等非递归的排序算法
3. 使用`dump`配合`pause`指令，观察函数调用前后栈和`ip`、`sp`寄存器的变化情况

# lesson-5 参数，返回值，局部变量，函数 stack frame 的运行机制

作为模块化的基本单元，函数需要满足以下要求：
1. 需要清晰的约定参数和返回值的传递方式，即C语言中的函数接口定义
2. 需要约定堆栈的使用方式，谁负责清理堆栈，还原sp寄存器，这就产生了`stdcall`和`cdecl`等编译层面需要关心的细节
3. 除了以上两点，函数应当是自包含的，互不影响的，不再依赖任何外界的条件
4. 考虑一个计算过程比较复杂的函数，4个寄存器是不够用的，必须需要在内存中存放各种中间结果，即局部变量，一个函数可以在内存固定的位置存放中间结果，但是会有两个问题：
   1. 这个位置其他函数不能用，避免覆盖，所以需要所有的函数都知道其他函数用了哪儿，自己能用哪儿，不能用哪儿，当函数多了之后，这显然是无法维护的
   2. 对于递归函数，自己调用自己，那么同一个位置必然要被自己覆盖掉，导致计算过程无法回退，从而整个事情就无法实现了

每个函数的工作台，即其专属的内存空间，有个专门的名字叫`frame`，例如C#中有个专门的类就叫`StackFrame`
我们使用`frame`的机制来满足以上需求，实际上，参数、返回值、局部变量、`ip`和`bp`寄存器，都是使用栈保存的。
通过一个巧妙的机制，让`sp`和`bp`寄存器相互配合，就能实现上述的全部需求。

## 函数`frame`的内存布局

用一个例子演示这个巧妙的机制是如何实现的。
假设一个简单的函数 f1(a,b) = a+b+1
这个函数有两个参数 a 和 b，有一个返回值，计算时需要两个临时变量

那么这个函数的frame的内存布局如下（注意栈是向下生长的，参数是从后向前入栈的，此处演示使用栈而不是寄存器返回结果）：

```
------------------
[bp+5] b   第二个参数   <-- 开始一次函数调用前，sp 指向这个位置
[bp+4] a   第一个参数
[bp+3] r   函数的返回值
[bp+2] ip  调用 call 时 ip 压入栈
[bp+1] bp  前一个 frame 的起点
[bp+0] x1  函数内部运算时需要的临时变量  <-- 执行函数内部的指令时，bp 指向这个位置
[bp+1] x2  第二个临时变量
[]         <-- 执行函数内部的指令时，sp 指向这个位置，即下一个可用的栈的位置
```

调用函数的方式：

```
push ax         ; 第一个参数
push bx         ; 第二个参数
sub sp, 1       ; 为返回值预留位置
call _f1        ; ip 自动入栈，并跳转到 _f1 位置
pop ax          ; 获得返回值，存入ax中
add sp, 2       ; 函数调用完毕，参数不能再继续占据内存
```

对应的函数的实现：

```
_f1:
    ; 创建新的frame
    push bp
    mov bp, sp

    ; 为临时变量预留空间
    sub sp, 2
    
    ; 参数的访问
    mov ax, [bp+4] ; 第一个参数
    mov bx, [bp+5] ; 第二个参数

    ; 开始函数计算，其实可以不用临时变量，此处只为演示临时变量的用法
    mov [bp], ax
    mov [bp-1], bx
    mov ax, 0
    add ax, [bp]
    add ax, [bp-1]
    add ax, 1

    ; 返回值
    mov [bp+3], ax

    ; 退回之前的frame
    mov sp, bp
    pop bp

    ; ip出栈，函数返回
    ret
```

## 任务

1. 使用 `step` 的逐步模式，观察上述代码执行的每一步过程中，栈和各个寄存器的变化情况
2. 使用递归函数实现斐波那契数列的计算，并使用 `step` 和 `animation` 模式跟踪观察递归函数的调用和返回的过程


# lesson-6 大实验：排序算法

到目前为止，一个抽象意义上的计算机已经功能齐全了，可以实现一些复杂的功能了，我们可以实现各种排序算法，以熟练上述内容

## 任务

- 随机生成100个数，存到内存里，将其排序，输出排序前和排序后的结果，这一步可以先使用交换排序、冒泡排序等各种基于循环的、非递归的排序算法
- 实现递归的快速排序


# lesson7 真实世界的汇编语言

[dasm](dasm) 目录下有几个.c源代码和对应的.asm文件，.asm文件是visual studio的编译器生成的，
例如fib.asm文件是通过 `cl /FAs fib.c` 生成的，可以通过.asm文件观察真实世界的编译器是如何将c语言翻译成汇编语句的。
如果有C语言的基础，再观察从C翻译成的汇编代码，会更有助于加深对C的理解。

# 汇总

## 寄存器

- 通用寄存器：ax bx cx dx
- 符号寄存器：flg
    - 只能通过cmp popf赋值
- 指令寄存器：ip
    - 系统启动时，初始化为0
- 栈寄存器：bp sp
    - 系统启动时，sp初始化为1023
    - 某些指令会改变sp的值，sp和bp是专门用于栈操作的，需要遵循规范使用

## 程序语法

- 用;表示注释
- 每一行一条指令，指令全部小写
- 指令可以有标签，标签可以单独占一行，和下一行的指令是一个整体

## 指令一览

以 [toy_asm.g4](antlr/idl/toy_asm.g4) 中的 antlr 描述为准
