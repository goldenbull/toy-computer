# 介绍

用于计算机编程的入门教学。

引入一个极度简化、抽象后的计算机模型，只包含最简单的CPU和内存，逐步引入各种类ASM汇编指令

# 最基本的规则

1. 整个系统只有几个概念：指令、CPU、寄存器、数字、内存
2. 指令：程序的最基本单位，一条语句就是一个指令，由CPU负责执行，每条指令的执行逻辑都是极度简单、清晰、明确的，指令的语句全部使用小写，每条指令前还可以有一个或多个自定义的标签
3. CPU、寄存器：负责执行指令，但这个部分目前可以跳过，可以简单的认为CPU只由寄存器构成，每个寄存器是一个小格子，可以存一个数字
4. 数字：只处理有符号整数，且不考虑字节数
5. 内存，用来保存数据和指令
    1. 数据内存由1024个小格子组成，和寄存器一样，每个格子也可以存一个数字，所有格子顺序编号，0-base
    2. 指令内存也是一堆小格子，每个格子一条指令，也顺序编号，且每条指令可以有一个自定义的label
    3. 内存和寄存器的区别：内存比寄存器慢100倍，但量大便宜

# lesson-1 寄存器的简单操作

引入4个通用寄存器ax bx cx dx

引入8条指令：mov add sub mul div input print rand

| 指令    | <div style="width:100px">格式</div> | 含义                                                                      | <div style="width:150px">样例</div>                            |
|-------|-----------------------------------|-------------------------------------------------------------------------|--------------------------------------------------------------|
| mov   | `mov r1, N`                       | 将数字N存入寄存器r1中                                                            | `mov ax, 0`<br/>`mov bx, 100`                                |
|       | `mov r1, r2`                      | 将寄存器r2的值存入寄存器r1中<br/>r1被覆盖，r2保持不变                                       | `mov ax, bx`                                                 |
| add   | `add r1, N`                       | 将数字N和寄存器r1中的数字相加<br/>结果依然存入r1中                                          | `mov ax, 1`<br/>`add ax, 2`<br/>此时，ax中的值为3                   |
|       | `add r1, r2`                      | 将寄存器r1和r2中的数字相加<br/>结果存入r1中，r2保持不变                                      | `mov ax, 1`<br/>`mov bx, 2`<br/>`add ax, bx`<br/>此时ax=3，bx=2 |
| sub   | `sub r1, N`                       | 减法，`r1-N --> r1`                                                        |                                                              |
|       | `sub r1, r2`                      | `r1-r2 --> r1`                                                          |                                                              |
| mul   | `mul N`                           | 乘数必须预先放入ax中，结果是ax*N，也放在ax里<br/>即 `ax*N --> ax`                          | `mov ax, 3`<br/>`mul 4`<br/>此时，ax中的值为12                      |
|       | `mul r1`                          | `ax*r1 --> ax`                                                          |                                                              |
| div   | `div N`                           | 整数除法，被乘数必须预先放入ax中<br/>ax除以N，商在ax中，余数在dx中<br/>余数始终和ax符号相同，如果N为0，系统死机     | `mov ax, 11`<br/>`div 4`<br/>此时ax=2,dx=3                     |
|       | `div r1`                          | ax除以r1，其余同上                                                             |                                                              |
| input | `input r1`                        | 用户输入一个数字，存入r1中，格式错误则直接死机                                                | `input ax`                                                   |
| print |                                   | 输出数字或字符串到屏幕上，这实际上是一个伪指令，允许使用C风格的字符串。有`print`和`println`两个指令，区别是在末尾是否自动换行 |                                                              |
|       | `print N`                         |                                                                         |                                                              |
|       | `print r1`                        |                                                                         | `print cx`                                                   |
|       | `print STR`                       |                                                                         | `print "hello"`                                              |
|       | `println N`                       |                                                                         |                                                              |
|       | `println r1`                      |                                                                         | `println cx`                                                 |
|       | `println STR`                     |                                                                         | `println "hello"`                                            |
|       | `println`                         | 等价于`print "\n"`                                                         |                                                              |
| rand  | `rand r1`                         | 将一个随机数存入r1中，随机数的范围限制在[0, 999]，足够随机，且方便显示                                | `rand ax`                                                    |

## 需要完成的任务

1. 从1加到3，输出结果
2. 输入两个数，输出两个数的加减乘除的各种结果
3. 从1加到10，输出结果

# lesson-2 内存操作

4个寄存器只能保存4个数字，可以做的事情是非常少的，如果需要保存更多的数字，就需要用到内存了，内存统一通过`[寄存器+偏移量]`
的格式访问，上述各个指令操作内存的格式如下：

| 指令    | <div style="width:120px">格式</div> | 含义                                                                | <div style="width:150px">样例</div>                                        |
|-------|-----------------------------------|-------------------------------------------------------------------|--------------------------------------------------------------------------|
| mov   | `mov [r1+N1], N2`                 | 将数字N2写入内存， `[r1+N1]`表示内存中编号为r1+N1的格子，N1为0时可以省略不写，也可以为负数，如`[ax-4]` | `mov cx, 1`<br/>`mov [cx], 123`<br/>将数字123存入内存中的第2个格子里，格子编号是1（因为是0-base） |
| mov   | `mov [r1+N], r2`                  |                                                                   | `mov ax, 456`<br/>`mov cx, 1`<br/>`mov [cx], ax`<br/>                    |
|       | `mov r1, [r2+N]`                  | 读内存，写入寄存器                                                         |                                                                          |
| add   | `add r1, [r2+N]`                  |                                                                   |                                                                          |
| sub   | `sub r1, [r2+N]`                  |                                                                   |                                                                          |
| mul   | `mul [r1+N]`                      |                                                                   |                                                                          |
| div   | `div [r1+N]`                      |                                                                   |                                                                          |
| input | `input [r1+N]`                    |                                                                   |                                                                          |
| print | `print [r1+N]`                    |                                                                   |                                                                          |
|       | `println [r1+N]`                  |                                                                   |                                                                          |
| rand  | `rand [r1+N]`                     |                                                                   |                                                                          |

为方便调试，再引入几个指令

| 指令   | <div style="width:120px">格式</div> | 含义                                             | <div style="width:150px">样例</div> |
|------|-----------------------------------|------------------------------------------------|-----------------------------------|
| dump | `dump`                            | 输出当前的计算机运行状态，用于观察、调试程序的运行过程，显示正在运行的指令上下文、所有寄存器 | `dump`                            | 
|      | `dump r1, N`                      | 除了上述内容，还显示内存中`[r1]`到`[r1+N-1]`的内容，N必须大于等于0     | `dump cx, 32`                     |
|      | `dump N1, N2`                     |                                                | `dump 512, 32`                    |
| halt | `halt`                            | 立即结束运行，进入停机状态                                  | `halt`                            |
| nop  | `nop`                             | no operation的缩写，什么事情也不干，CPU空转一次，继续下一条指令        | `nop`                             |

## 需要完成的任务

1. 输入6个数，输出这6个数的累加值
2. 生成10个随机数并显示，然后输入两个编号选择其中的两个数，输出这两个数的加减乘除的各种结果

# lesson-3 循环

以上各个任务中，已经出现了一些反复执行的代码片段，我们引入循环，避免不必要的重复

为了实现**反复执行同一段代码**的功能，引入新的指令`jmp`

| 指令  | <div style="width:120px">格式</div> | 含义                 | <div style="width:150px">样例</div>                                                       |
|-----|-----------------------------------|--------------------|-----------------------------------------------------------------------------------------|
| jmp | `jmp label`                       | 跳到`label`对应的指令继续执行 | `mov ax, 1`<br/>`repeat: add ax, 1`<br/>`println ax`<br/>`jmp repeat`<br/>一个打印自然数序列的死循环 | 

只有`jmp`的话，只能实现死循环，还需要根据某种条件判断，中断循环，因此需要引入新的寄存器和指令

- 引入寄存器`flg`，不能通过`mov`写入，只能通过`cmp`指令写入

引入`cmp`指令和条件跳转指令

| 指令  | <div style="width:120px">格式</div> | 含义                                                                           | <div style="width:150px">样例</div> |
|-----|-----------------------------------|------------------------------------------------------------------------------|-----------------------------------|
| cmp | `cmp r1, N`                       | 比较r1和N的大小<br/>`r1>N ---> flg=1`<br/>`r1==N --> flg=0`<br/>`r1<N ---> flg=-1` |                                   |
|     | `cmp r1, r2`                      |                                                                              |                                   |
|     | `cmp r1, [r2+N]`                  |                                                                              |                                   |
| je  | `je label`                        | jump if equal，flag=0则跳转                                                      |                                   |
| jne | `jne Label`                       | jump if not equal，flag!=0则跳转                                                 |                                   |
| jg  | `jg Label`                        | jump if greater，flag>0则跳转                                                    |                                   |
| jge | `jge Label`                       | jump if greater or equal，flag>=0则跳转                                          |                                   |
| jl  | `jl Label`                        | jump if less，flag<0则跳转                                                       |                                   |
| jle | `jle Label`                       | jump if less or equal，flag<=0则跳转                                             |                                   |

## 需要完成的任务

1. 从1加到10，输出结果
2. 生成100个随机数并显示，然后输入两个编号选择其中的两个数，输出这两个数之和
3. 输出斐波那契数列的前100项
4. 输入一个数，判断这个数是否是7的倍数
5. 输入一个数，判断这个数的十进制表达里面是否包含7，比如17，271，37，76
6. 输入一个数，判断这个数是否是7的倍数或者包含7
7. 酒桌小游戏：从1到100，轮流数数，跳过所有7的倍数或者包含7的数
8. 输入一个数，判断是否是质数
9. 输出100以内的所有质数，要求：
    1. 复用8已经写好的代码
    2. 将需要判断的数预先存放在ax中，调用8的代码，结果也放在ax中
    3. 在调用之前，把寄存器的数保存到内存特定位置，等从8的代码jmp回来之后，再从内存中恢复之前保存的寄存器的值
10. 使用筛法输出10000以内的质数

# lesson-4 代码模块化问题

前面已经出现了需要重复使用某一段代码F的情况。我们首先考虑寄存器和内存的问题：

1. 调用者在使用F前，有可能需要把寄存器的值保存到内存里，等使用完毕后，再从内存中读回来
2. CPU中只有4个寄存器，如果F的计算逻辑稍微复杂一点，也需要用内存去保存中间结果
3. F还可能会调用其他的F2，F2再调用F3，层层嵌套，保存中间结果的位置该怎么约定，才能避免互相覆盖？

考虑到这实际上是一个逐层深入、逐层退出的过程，我们在内存中使用一个栈（stack）数据结构来解决以上问题。为方便使用栈，我们引入一个新的寄存器sp：

- sp
    - stack pointer的意思
    - 记录下一个空闲的可以存放指令序号的内存位置，不妨在系统初始化时设为512
    - 是一个通用寄存器，用户可以随意操作
    - 某些指令会自动使用sp做一些操作，改变sp的值，因此虽然用户可以随意操作，但如果违反了统一的约定，就会导致程序出错

引入栈的概念和sp寄存器之后，内存就分为两个部分了，前面512个格子是程序可以随意使用的，称为 **堆（heap）**，后面512个格子是给 *
*栈（stack）** 专用的，sp始终指向栈的顶部的空闲位置

为了更方便的操作sp寄存器，我们引入新的指令：

| 指令    | <div style="width:120px">格式</div> | 含义                                                                | <div style="width:150px">样例</div>                                                     |
|-------|-----------------------------------|-------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| push  | `push N`                          | 等价于<br/>`mov [sp], N`<br/>`add sp, 1`                             | `mov ax, sp`<br/>`dump ax, 10`<br/>`push 123`<br/>`dump ax, 10`<br/>观察push前后的寄存器和内存情况 |  
|       | `push r1`                         | 等价于<br/>`mov [sp], r1`<br/>`add sp, 1`<br/>r1只能是通用寄存器 ax bx cx dx |                                                                                       |
| pop   | `pop r1`                          | 等价于<br/>`sub sp, 1`<br/>`mov r1, [sp]`                            |                                                                                       |
|       | `pop`                             | 等价于<br/>`sub sp, 1`<br/>                                          |                                                                                       |
| pushf | `pushf`                           | flg寄存器压入栈                                                         |                                                                                       |
| popf  | `popf`                            | 从栈中取出flg                                                          |                                                                                       |
## 任务

重新审视前面的任务3-9和3-10，使用push和pop实现，使用dump观察栈的情况

# lesson-5 jmp指令的实质和IP寄存器

通过dump指令理解jmp指令是如何将字符串形式的label转换为数字的，例如运行以下代码：
```
    mov ax, 0
loop1:
    add ax, 1
    println ax
    cmp ax, 100
    jne loop1
    je continue
    print "this op will be skipped"
continue:
    print "jump to here"
    dump
```

重点观察每条jmp指令后面的offset

引入ip寄存器

- ip
  - instruction pointer的意思
  - 实际上这个寄存器之前已经隐形的存在了，用于记录下一步将要执行的指令的序号，CPU下一步执行哪条指令，完全依赖这个寄存器的值
  - 系统启动时设为0
  - 非跳转指令，自动+1
  - 跳转指令，设置为目标指令的序号

## 任务

使用dump指令观察jmp指令的实现逻辑

# lesson-6 函数

有了sp寄存器和内存中的栈结构，各模块间的内存可以做到互相不影响了，但还有一个功能无法实现。

考虑以下这两个任务：

- （3-9已经实现的）假设有一个数已经预先存放在ax中，写一段代码片段，判断这个数是否是质数，结果也放在ax中
- （无法实现的）从代码的两个不同位置，jmp到这段代码，计算完毕后jmp回出发点

将一段代码变成可以重复调用的函数，会有一系列问题：

1. 如何跳转回去：jmp指令的跳转目标是代码中写死的，不能动态修改，一个直观的想法，是通过保存和恢复ip寄存器来实现这个功能，jmp之前，想办法保存当前指令的序号，函数执行完毕后，jmp回来继续执行即可
2. 调用者并不确定函数会用到哪些寄存器，所以当前指令的序号只能保存在内存里，且必须是事先约定的内存位置
3. 函数还会调用其他函数，因此保存指令序号的内存位置还会不断递增或递减，如何避免互相覆盖？
4. 函数还有参数和返回值的问题
5. 函数内部还需要保存各种中间结果，中间结果如果保存在内存固定位置的话，递归函数怎么办？

以上和内存相关的问题，实际上已经通过栈和sp指针解决了，接下来我们解决ip寄存器保存和恢复的问题

引入函数调用最核心的两条指令：call和ret指令

| 指令    | <div style="width:120px">格式</div> | 含义                                  | <div style="width:150px">样例</div>                                                     |
|-------|-----------------------------------|-------------------------------------|---------------------------------------------------------------------------------------|
| call | `call label` | 等价于<br/>`push ip+1`<br/>`jmp label` | |
| ret | `ret` | 等价于`pop ip`<br/>ip已经是下一条要执行的指令了     ||

需要注意的是程序里不能写`push ip+1`，这个写法只是表达这个含义

需要注意几点：

- call和ret指令会修改sp和ip的值
- ip不能用mov指令赋值，只能用jmp/je/jne/...这些跳转指令和call/ret指令赋值
- sp是一个通用寄存器，程序员可以随意操作，但由于call和ret会修改sp，因此需要按照规则正确使用sp

## 任务

运行以下递归函数，观察堆栈情况

```
    jmp main

f1:
    dump 512, 32
    mov ax, [sp-2] // 参数
    add ax, 1
    cmp ax, 10
    jg stop_recursive

    print "working on "
    print ax
    print " sp="
    println sp

    push ax
    call f1
    pop
stop_recursive:
    ret

main:
    push 0
    call f1
    pop
```

# lesson-7 参数，返回值，临时变量

作为模块化的基本单元，函数需要满足以下要求：
1. 需要清晰的约定参数和返回值的传递方式，即C语言中的函数接口定义
2. 需要约定堆栈的使用方式，谁负责清理堆栈，还原sp寄存器，这就产生了`stdcall`和`cdecl`等编译层面需要关心的细节
3. 除了以上两点，函数应当是自包含的，互不影响的，不再依赖任何外界的条件
4. 考虑一个计算过程比较复杂的函数，4个寄存器是不够用的，必须需要在内存中存放各种中间结果，一个函数可以在内存固定的位置存放中间结果，但是会有两个问题：
   1. 这个位置其他函数不能用，避免覆盖，所以需要所有的函数都知道其他函数用了哪儿，自己能用哪儿，不能用哪儿，当函数多了之后，这显然是无法维护的
   2. 对于递归函数，自己调用自己，那么同一个位置必然要被自己覆盖掉，导致计算过程无法回退，从而整个事情就无法实现了

为满足以上需求，解决递归函数的问题，实际上，参数、返回值、临时变量，都是使用栈保存的。进入函数前后，可以往栈里面继续增加内容，同一个函数，每次被调用时，sp寄存器都是指向栈的头部位置，不会产生覆盖的问题

为了更方便的使用栈，再引入一个新的寄存器：

- bp
  - base pointer的意思
  - bp是一个通用寄存器，完全是为了方便程序员而提供的，和sp一样，程序员也可以随意操作
  - 按统一的约定，专门用于进入函数时保存sp寄存器的值，之后sp可以改变，而同一个函数内部bp保持不变，以方便访问函数中的局部变量 

最后为方便程序员，再引入两条批处理性质的指令：

- pusha // 将所有通用寄存器入栈，依次是ax bx cx dx flg bp
- popa // 和pusha对应，以相反的顺序逐一出栈

## 任务

有了新的指令和寄存器，将之前的所有任务用函数重新实现一遍，做到：函数片段本身是自包含的，只需要约定参数和返回值的传递方式，此外无需知道调用者的任何信息

# lesson 8

到目前为止，一个抽象意义上的计算机已经功能齐全了，可以实现一些复杂的功能了，我们可以实现各种排序算法，以熟练上述内容

## 任务

- 随机生成100个数，存到内存里，将其排序，输出排序前和排序后的结果，这一步可以先使用交换排序、冒泡排序等各种基于循环的、非递归的排序算法
- 实现递归的快速排序

# lesson 9

到目前为止，CPU和内存的核心概念已经完备了，下一步是从一行行的指令（实际上就是汇编语言）到C语言的转换

## 任务

- 将以上汇编代码逐行翻译成C，从而理解C语言的底层机制
- 实际上如果有C语言的基础，从C翻译成汇编代码，可能会容易，而且更有助于加深对C的理解

# 汇总

## 寄存器

- 通用寄存器：ax bx cx dx
- 符号寄存器：flg
    - 只能通过cmp popf popa赋值
- 指令寄存器：ip
    - 系统启动时，初始化为0
- 栈寄存器：bp sp
    - 系统启动时，sp初始化为512
    - 某些指令会改变sp的值，sp和bp是专门用于栈操作的，需要特殊对待

## 程序语法

- 用//表示注释
- 每一行一条指令，指令全部小写
- 指令可以有标签，标签可以单独占一行，和下一行的指令是一个整体

样例：

```
start:
  mov ax, 0
  mov cx, 1
loop1:
  add ax, cx
  add cx, 1
  cmp cx, 10
  jg finished
  jmp loop1
finished:
  print ax
  dump ax, 0
```

## 指令一览

以 [toy_asm.g4](antlr/idl/toy_asm.g4) 中的 antlr 描述为准

## release

为方便使用，可以用 pyinstaller 打包

```
D:\src\toy-computer\src\py>pyinstaller -F main.py
```

使用 `-s` 或者 `--step` 参数可以进入逐行模式，每执行一条指令，就会自动执行一次 `dump 512, 64`